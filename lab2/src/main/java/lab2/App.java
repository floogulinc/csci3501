/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package lab2;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.DoubleSummaryStatistics;
import java.util.IntSummaryStatistics;
import java.util.List;
import java.util.Random;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;

import net.steppschuh.markdowngenerator.table.Table;
import net.steppschuh.markdowngenerator.table.TableRow;

/**
 * CSCI 3501 Lab 2 and 3
 *
 * @author Paul Friederichsen
 */
public class App {

    /**
     * Small class to implement {@link Sorter} with the built in TimSort from {@link java.util.Arrays}
     */
    public static class JavaTimSort implements Sorter {
        public <T extends Comparable<T>> void sort(T[] arr) {
            Arrays.sort(arr);
        }
    }


    /**
     *  An array generator has a function that generates an array 
     *  Used for lambdas
     */
    public interface ArrayGenerator<T> {
        /**
         * Generates an array
         * @return the generated array of items of type T
         */
        public T[] generateArray();
    }

    /**
     * The main method that is ran when the program starts
     * @param args The arguments to the program (can be none)
     */
    public static void main(String[] args) {

        if (args.length == 0) {
            regularTests(); // Run the regular tests if no arguments
        } else if (args[0].equals("testmedian")) {
            int runs = 10;
            IntSummaryStatistics summary = IntStream.range(0, runs).mapToObj(x -> testMedian()).collect(Collectors.summarizingInt(x -> x));
            System.out.println("----------------------------------------");
            System.out.println("STATS FOR BEST INDEX FOR " + runs +  " RUNS:");
            System.out.println("Average: " + summary.getAverage()); 
            System.out.println("Min: " + summary.getMin()); 
            System.out.println("Max: " + summary.getMax()); 
            System.out.println("Count: " + summary.getCount()); 
        } else if (args[0].equals("testinsert")) {
            int runs = 10;
            IntSummaryStatistics summary = IntStream.range(0, runs).mapToObj(x -> testInsert()).collect(Collectors.summarizingInt(x -> x));
            System.out.println("----------------------------------------");
            System.out.println("STATS FOR BEST INDEX FOR " + runs +  " RUNS:");
            System.out.println("Average: " + summary.getAverage()); 
            System.out.println("Min: " + summary.getMin()); 
            System.out.println("Max: " + summary.getMax()); 
            System.out.println("Count: " + summary.getCount()); 
        }

    }

    /**
     * The default set of tests to run when the program is ran
     */
    public static void regularTests() {

        Random rand = new Random();

        // number of times to repeat each test for
        int numRepeat = 5; 

        // Requires Java 9+, but the labs use 8 so I switched to Arrays.asList
        // List<Sorter> sorters = List.of(new JavaTimSort(), new QuickSort(), new RandomizedQS(), new MedianQS(20), new InsertionQS(6));
        
        List<Sorter> sorters = Arrays.asList(new JavaTimSort(), new QuickSort(), new RandomizedQS(), new MedianQS(20), new InsertionQS(6));

        System.out.println("#### Testing on 10,000 random ints 1-1,000,000:\n");
        List<List<Long>> allrandomresults = repeatTestSorts(sorters,() -> getRandomTestIntArray(1, 1000000, 10000, rand), numRepeat);
        System.out.println(makeMarkdownTable(allrandomresults, sorters));
        System.out.println("\n");

        System.out.println("#### Testing on the range 1-10000:\n");
        List<List<Long>> allrangeresults =  repeatTestSorts(sorters,() -> IntStream.rangeClosed(1, 10000).mapToObj(TestInteger::new).toArray(TestInteger[]::new), numRepeat);
        System.out.println(makeMarkdownTable(allrangeresults, sorters));
        System.out.println("\n");

        System.out.println("#### Testing on 10 sequences of ranges of 1000:\n");
        List<List<Long>> tenrangeresults =  repeatTestSorts(sorters,() -> rand.ints().limit(10).flatMap(r -> IntStream.range(r, r + 1000)).mapToObj(TestInteger::new).toArray(TestInteger[]::new), numRepeat);
        System.out.println(makeMarkdownTable(tenrangeresults, sorters));
        System.out.println("\n");

        System.out.println("#### Testing on 100 sequences of ranges 100:\n");
        List<List<Long>> hundredrangeresults =  repeatTestSorts(sorters,() -> rand.ints().limit(100).flatMap(r -> IntStream.range(r, r + 100)).mapToObj(TestInteger::new).toArray(TestInteger[]::new), numRepeat);
        System.out.println(makeMarkdownTable(hundredrangeresults, sorters));
        System.out.println("\n");
    }

    /**
     * Optimization for {@link MedianQS}
     * @return The value used that resulted in the fewest comparisons
     */
    public static int testMedian() {
        Random rand = new Random();
        int start = 1, end = 100;
        List<List<Long>> results = repeatTestSorts(IntStream.rangeClosed(start, end).mapToObj(x -> new MedianQS(x)).collect(Collectors.toList()), () -> getRandomTestIntArray(1, 1000000, 10000, rand), 10);
        List<Double> avg = getAverages(results);
        DoubleSummaryStatistics summary = avg.stream().collect(Collectors.summarizingDouble(x->x));     
        System.out.println("Average: " + summary.getAverage()); 
        System.out.println("Min: " + summary.getMin() + " at: " + (avg.indexOf(summary.getMin()) + start)); 
        System.out.println("Max: " + summary.getMax() + " at: " + (avg.indexOf(summary.getMax()) + start)); 
        System.out.println("Count: " + summary.getCount()); 
        return (avg.indexOf(summary.getMin()) + start);

        // full printout (this is pretty unreadable)
        //System.out.println(makeMarkdownTable(results, IntStream.rangeClosed(3, 100).mapToObj(x -> new MedianQS(x)).collect(Collectors.toList())));
    }

    /**
     * Optimization for {@link InsertionQS}
     * @return The value used that resulted in the fewest comparisons
     */
    public static int testInsert() {
        Random rand = new Random();
        int start = 1, end = 100;
        List<List<Long>> results = repeatTestSorts(IntStream.rangeClosed(start, end).mapToObj(x -> new InsertionQS(x)).collect(Collectors.toList()), () -> getRandomTestIntArray(1, 1000000, 10000, rand), 10);
        List<Double> avg = getAverages(results);
        DoubleSummaryStatistics summary = avg.stream().collect(Collectors.summarizingDouble(x->x));     
        System.out.println("Average: " + summary.getAverage()); 
        System.out.println("Min: " + summary.getMin() + " at: " + (avg.indexOf(summary.getMin()) + start)); 
        System.out.println("Max: " + summary.getMax() + " at: " + (avg.indexOf(summary.getMax()) + start)); 
        System.out.println("Count: " + summary.getCount()); 
        return (avg.indexOf(summary.getMin()) + start);

        // full printout (this is pretty unreadable)
        //System.out.println(makeMarkdownTable(results, IntStream.rangeClosed(3, 100).mapToObj(x -> new MedianQS(x)).collect(Collectors.toList())));
    }

    /**
     * Creates a markdown table from the results of {@link #repeatTestSorts}
     * @param sortComparisons The list of lists of sorting test results from {@link repeatTestSorts}
     * @param sorters List of {@link Sorter} instances that were used, for the table headers
     * @return The markdown table of number of comparisons for each run of each sorter and averages for each sorter
     */
    public static Table makeMarkdownTable(List<List<Long>> sortComparisons, List<Sorter> sorters) {
        Table.Builder tableBuilder = new Table.Builder().addRow(new TableRow<String>(sorters.stream().map((s) -> s.getClass().getSimpleName()).collect(Collectors.toList())));

        sortComparisons.forEach(sc -> tableBuilder.addRow(new TableRow<Long>(sc)));

        tableBuilder.addRow(new TableRow<String>(Collections.nCopies(sorters.size(), " ")));
        List<String> avgLine = new ArrayList<String>(Collections.nCopies(sorters.size(), " "));
        avgLine.set(((sorters.size()-1)/2), " **Average** ");

        tableBuilder.addRow(new TableRow<String>(avgLine));

        tableBuilder.addRow(new TableRow<Double>(getAverages(sortComparisons)));

        return tableBuilder.build();
    }

    /**
     * Generate averages for each type of sorter
     * @param sortComparisons  The list of lists of sorting test results from {@link repeatTestSorts}
     * @return A list of averages for each type of sorter
     */
    public static List<Double> getAverages(List<List<Long>> sortComparisons) {

        int numTests = sortComparisons.size();
        int numSorters = sortComparisons.get(0).size();

        ArrayList<Long>[] elements = new ArrayList[numSorters];
        for(int i = 0; i < numTests; i++) {
            for(int j = 0; j < numSorters; j++) {
                if (elements[j] == null) elements[j] = new ArrayList<Long>();
                elements[j].add(sortComparisons.get(i).get(j));
            }
        }

        return Stream.of(elements).map(el -> el.stream().collect(Collectors.averagingLong(x -> x))).collect(Collectors.toList());
        
    } 

    /**
     * Repeat {@link #testSorts} a given number of times with arrays generated by the given generator
     * @param sorters The list of {@link Sorter} instances to use for each sorting run
     * @param arrayGen The {@link ArrayGenerator} to use to generate new arrays to test with
     * @param repeat How many times to repeat the {@link #testSorts} process 
     * @return A list of the lists of number of comparisons from {@link #testSorts}
     */
    public static List<List<Long>> repeatTestSorts(List<Sorter> sorters, ArrayGenerator<TestInteger> arrayGen, int repeat) {
        return IntStream.range(0, repeat).mapToObj((i) -> testSorts(sorters, arrayGen.generateArray())).collect(Collectors.toList());
    }

    /**
     * Tests multiple sorters on the same array using {@link #testSortArray}
     * @param sorters The list of {@link Sorter} instances to use
     * @param arr The array to sort with each of the given sorters
     * @return A list of the number of comparisons for each of the sorters given in the same order
     */
    public static List<Long> testSorts(List<Sorter> sorters, TestInteger[] arr) {
        // for(Sorter s : sorters) {
        //     TestInteger[] testArr = arr.clone();
        //     testSortArray(s, testArr);
        // }
        return sorters.stream().map((s) -> testSortArray(s, arr.clone())).collect(Collectors.toList());
    }

    /**
     * Runs a sorter on the given array and returns the number of compares from TestInteger
     * @param sorter The sorter class to use
     * @param arr The array to sort
     * @return The number of compares that took place during the sorting
     */
    public static long testSortArray(Sorter sorter, TestInteger[] arr) {
        //System.out.println("Testing " + sorter.getClass().getSimpleName() + " with array of " + arr.length + " elements");
        TestInteger.resetCounter();
        sorter.sort(arr);
        long compareCount = TestInteger.getCounter();
        TestInteger.resetCounter();
        if(!isSorted(arr)) // Error if an array is ever not sorted
            System.err.println("Error: an array was not sorted when it should have been (" + sorter.getClass().getName() + ")");

        //System.out.println("Array is " + (isSorted(arr) ? "sorted" : "not sorted") + ", Compare Count: " + compareCount);
        return compareCount;
    }

    /**
     * Creates an array of random {@link TestInteger} objects
     * @param min The lowest possible value to generate
     * @param max The largest possible value to generate
     * @param size The size of the array to produce
     * @param rnd Instance of {@link java.util.Random}
     * @return An array of random TestIntegers
     */
    public static TestInteger[] getRandomTestIntArray(int min, int max, int size, Random rnd) {
        // Streams are pretty neat
        return rnd.ints(min, max).limit(size).mapToObj(TestInteger::new).toArray(TestInteger[]::new);
    }

    /**
     * Checks whether the given array is sorted
     * @param <T> the class of the objects in the array, must implement {@link Comparable}
     * @param arr The array to check
     * @return {@code true} if the given array is sorted
     */
    public static <T extends Comparable<T>> boolean isSorted(T[] arr) {
        for (int i = 1; i < arr.length; i++) {
            if (arr[i - 1].compareTo(arr[i]) > 0) {
                return false;
            }
        }
        return true;
    }
}
